#lang racket/base
;;;
;;; Stream Plots
;;;  

;; Given a differential equation of the form
;;   y' = f(x,y)
;; a stream plot shows multiple solutions curves.

;; The stream plot attempts to plot solutions curves that
;; doesn't lie too close to each other.

;; First a set of starting points is generated.
;; Then a solution curve through each starting point is drawn.
;; When a solution curve gets too close to an already drawn
;; curve the curve is cut off.

;; This is done by dividing the plot window into 30x30 (when density=1)
;; rectangular cells. When a curve is drawn, the cells that
;; it touch are marked. Only starting points that lie in
;; untouched cells are drawn. If the option #:unbroken-trajectories?
;; is true, then curves aren't cut off, but are allowed to continue.
;; The default is to cut the curves.

;; The starting points are generated by `generate-start-points`.
;; The order of the starting points affect the visual esthetic.
;; Two orderings that produce nice looking figures are:
;;   - random order
;;   - sorted according to their distance from the mid point

(require  metapict metapict/system metapict/axis         
          (except-in metapict ellipse first-value label table)          
          racket/list racket/match)

(provide stream-plot)

;;;
;;; Buckets
;;;

;; An instance of buckets keeps track of which rectangular cells
;; have been touched by a solution curve.
;; The hash table ht is map from cell representatives to booleans.
;; The functions `touch!` and `touched?` are used to query the hash table.
;; They both take an x and y coordinate from the domain.
;; The `info` field holds the window and the size of the rectangles.

(struct buckets (ht touch! touched? info) #:transparent)

(define (make-buckets xmin xmax ymin ymax dx dy)
  ; We divide the rectange [xmin,xmax]x[ymin,ymax] into
  ; small rectangles of size dx*dy. The rectangles are buckets.
  (define (repr x y)
    (cond
      [(or (< x xmin) (> x xmax)
           (< y ymin) (> y ymax))
       'out-of-bounds]
      [else
       (cons (inexact->exact (floor (/ (- x xmin) dx)))
             (inexact->exact (floor (/ (- y ymin) dy))))]))
  ; The hash tables stores for each bucket, whether it is touched.
  ; A bucket is touched, when we draw in it.
  (define ht (make-hash))
  (define (touch!   x y) (hash-set! ht (repr x y) #t))
  (define (touched? x y) (hash-ref  ht (repr x y) #f))
  (buckets ht touch! touched? (list xmin xmax ymin ymax dx dy)))


; Returns a table of points before and after (x0,y0).
; Here f : RxR -> R comes from the differential equation y'=f(x,y).
(define (runge-kutta f x0 y0 xmin xmax h)
  (values (runge-kutta/backward f x0 y0 xmin h)
          (runge-kutta/forward  f x0 y0 xmax h)))


; Initial value problem:
;    dy/dx = f(x,y);  y(x0)=y0
; where y is an unknown function.
(define (runge-kutta/forward f x0 y0 xmax h)  
  ; RK4 - forward
  ;   y_{n+1} := y_n + 1/6 (k₁ + 2k₂ + 2 k₃ + k₄) h,
  ;   k₁ = f(x_n,       y_n         )
  ;   k₂ = f(x_n + h/2, y_n + h/2 k₁)
  ;   k₃ = f(x_n + h/2, y_n + h/2 k₂)
  ;   k₄ = f(x_n + h  , y_n + h   k₃)

  ; Use this page to produce test cases:
  ; https://homepages.bluffton.edu/~nesterd/apps/slopefields.html

  (define (next xn yn)
    (define h/2 (/ h 2))
    (define k₁ (f    xn         yn))
    (define k₂ (f (+ xn h/2) (+ yn (* h/2 k₁))))
    (define k₃ (f (+ xn h/2) (+ yn (* h/2 k₂))))
    (define k₄ (f (+ xn h)   (+ yn (* h   k₃))))
    (+ yn (/ (* h (+ k₁ (* 2. k₂) (* 2. k₃) k₄)) 6.)))

  (for/fold ([yn y0] [pts '()] #:result (reverse pts))
            ([xn (in-range x0 (+ xmax h) h)])
    (define y+ (next xn yn))
    (values y+ (cons (list xn yn) pts))))

(define (runge-kutta/backward f x0 y0 xmin h)
  ; RK4 - backwards
  ;   y_{n+1} := y_n - 1/6 (k₁ + 2k₂ + 2 k₃ + k₄) h,
  ;   k₁ = f(x_n,       y_n         )
  ;   k₂ = f(x_n - h/2, y_n - h/2 k₁)
  ;   k₃ = f(x_n - h/2, y_n - h/2 k₂)
  ;   k₄ = f(x_n - h  , y_n - h   k₃)

  ; Use this page to produce test cases:
  ; https://homepages.bluffton.edu/~nesterd/apps/slopefields.html

  (define (next xn yn)
    (define h/2 (/ h 2))
    (define k₁ (f    xn         yn))
    (define k₂ (f (- xn h/2) (- yn (* h/2 k₁))))
    (define k₃ (f (- xn h/2) (- yn (* h/2 k₂))))
    (define k₄ (f (- xn h)   (- yn (* h   k₃))))
    (- yn (/ (* h (+ k₁ (* 2. k₂) (* 2. k₃) k₄)) 6.)))

  (for/fold ([yn y0] [pts '()] #:result (reverse pts))
            ([xn (in-range x0 (- xmin h) (- h))])
    (define y+ (next xn yn))
    (values y+ (cons (list xn yn) pts))))



(define (stream-plot f xmin xmax ymin ymax
                     #:samples [n 50]
                     #:pts [pts #f]
                     #:draw-solution? [draw-solution? #f]
                     #:unbroken-trajectories? [unbroken-trajectories? #f]
                     #:draw-starting-points?  [draw-starting-points? #f] ; for debug
                     )
  
  (define win (window xmin xmax ymin ymax))
  (with-window win
    ; coordinate system
    (def s (system (pt 0 0) (vec 1 0) (vec 0 1) "" "")) ; todo: x-pict and y-pict
    (defm (system: _ a1 a2) s)
    ; convert from s to device coordinats
    (def (Pt x y) (point->pt (point s x y)))     
    ; ticks in visible range
    (defv (vxmin vxmax)           (visible-range a1 win))
    (defv (vymin vymax)           (visible-range a2 win))
    (def x-gap                    (find-gap-size vxmin vxmax #:at-least 5))
    (def y-gap                    (find-gap-size vymin vymax #:at-least 5))
    (defv (tick-x-min tick-x-max) (find-first/last-tick-in-range vxmin vxmax x-gap))
    (defv (tick-y-min tick-y-max) (find-first/last-tick-in-range vymin vymax y-gap))

    #;(define (slope-segment x y)
      (def u (px 4))
      (def slope (f x y))
      (def α (atan slope))
      (def c (* u (cos α)))
      (def s (* u (sin α)))
      ;; (define (c dx) (/ dx u))
      (defm (pt x1 y1) (Pt x y))
      (def sc (curve (Pt (- x c) (- y1 s)) .. (Pt (+ x c) (+ y1 s))))
      sc)

    ;; The function `rk4` computes the solutions that passes through (x0,y0).
    ;; Only if the point (x0,y0) is untouched according to `bs` an instance of `buckets`,
    ;; the solution curve is drawn.
    ;; After the curve is drawn, the buckets instance `bs` is updates, so that
    ;; later curves doesn't come too close to this curve.
    (define (rk4 bs x0 y0)
      (define touched? (buckets-touched? bs))
      (define touch!   (buckets-touch!     bs))
      (define (untouched? x y) (not (touched? x y)))

      (cond
        ; Ignore starting points that lie in a touched cell.
        [(touched? x0 y0) (draw)]
        [else
         ; Compute the solution curve through (x0,y0).
         (defv (before after) (runge-kutta f
                                           x0 y0        ; (x0,y0)
                                           vxmin vxmax  ; interval
                                           0.1))        ; step size h
         ; Now `before` and `after` are lists of points.

         ;; Helper functions

         ; Turn a list of (list x y) into a curve
         (define (points->curve xys)
           (def pts (map (λ (xy) (apply Pt xy)) xys))
           (and (not (empty? xys))
                (curve* (add-between pts --))))
         ; drop points in touched buckets
         (define (drop-touched xys)
           (dropf xys (λ (xy) (not (apply untouched? xy)))))
         ; take points in untouched buckets
         (define (take-untouched xys)
           (takef xys (λ (xy) (apply untouched? xy))))
         ; only keep points until first point in a touched cell
         (define (cut-off xys)
           (if unbroken-trajectories?
               xys
               (take-untouched xys)))
         
         ; find the untouched points, turn them into curves
         (define untouched-points-before (cut-off before))
         (define untouched-points-after  (cut-off after))
         (define curve-before            (points->curve untouched-points-before))
         (define curve-after             (points->curve untouched-points-after))

         (define (touch-segment! x y X Y)
           (match-define (list xmin xmax ymin ymax dx dy) (buckets-info bs))
           (define (sqr x) (* x x))
           (define dist  (sqrt (+ (sqr (- x X)) (sqr (- y Y)))))
           (define d     (sqrt (+ (sqr dx) (sqr dy))))
           (for ([t (in-range 0 1 (max 0.1 (min 0 (/ d (* 20 dist)))))])
             (touch! (+ (* t x) (* (- 1 t) X))
                     (+ (* t y) (* (- 1 t) Y)))))

         (define (mark-points-as-touched xys)
           (define prev-x #f)
           (define prev-y #f)
           (for ([xy xys])
             (match-define (list x y) xy)
             (touch! x y)
             (when prev-x (touch-segment! prev-x prev-y x y))
             (set! prev-x x)
             (set! prev-y y)))

         (mark-points-as-touched untouched-points-before)
         (mark-points-as-touched untouched-points-after)
           
         
         ; draw
         (draw curve-before curve-after)]))
    

    (define buckets (make-buckets xmin xmax ymin ymax 0.2 0.2))
    (draw                    
     s             
     (system-ticks s #:size 4)
     (tick-labels-in-range a1 tick-x-min tick-x-max x-gap #:fill #f #:opposite #t #:omit '(0) #:omit-last #t)
     (tick-labels-in-range a2 tick-y-min tick-y-max y-gap #:fill #f #:opposite #t #:omit '(0) #:omit-last #t)

     (for/draw ([p pts])
       (defm (pt x0 y0) p)
       (draw (color "red" (rk4 buckets x0 y0))
             (and draw-starting-points?
                  (penwidth 4 (color "blue" (draw (Pt x0 y0))))))))))

(define (generate-start-points win #:density [density 1])
  ; density: A density of 1 divides the window into 30x30 rectangles.
  ;          A density of 2 divides the window into (2*30)x(2*30) rectangles.  
  (match-define (window xmin xmax ymin ymax) win)
  (define dx (/ (- xmax xmin) (* density 30)))
  (define dy (/ (- ymax ymin) (* density 30)))
  (define pts (append* (for/list ([x (in-range xmin (+ xmax dx) dx)])
                         (for/list ([y   (in-range ymin (+ ymax dy) dy)]
                                    [row (in-naturals 0)])
                           ; every second row is shifted slightly
                           (if (even? row)
                               (pt x y)
                               (pt (+ x (/ dx 2)) y))))))
  (define mid (pt (/ (+ xmin xmax) 2.) (/ (+ ymin ymax) 2.)))
  (define (compare p q) (> (dist p mid) (dist q mid)))
  #;(sort pts compare)  
  (shuffle pts))


(set-curve-pict-size 300 300)
(define (f x y) (+ x y))
(define (g x y) (- (* x x) y))
(define pts (generate-start-points (window -5.5 5.5 -5.5 5.5) #:density 0.4))

(beside
 (draw (stream-plot g -3.5 3.5 -3.5 3.5 #:samples 5 #:pts pts
                    #:unbroken-trajectories? #t))
 (blank 30 10)
 (draw (stream-plot g -3.5 3.5 -3.5 3.5 #:samples 5 #:pts pts)))





 

